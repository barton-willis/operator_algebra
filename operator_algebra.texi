 \input texinfo  @c -*-texinfo-*-
@c @setfilename operator_algebra.html
@c makeinfo -v --html C:\\Users\\barto\\OneDrive\\Documents\\GitHub\\operator_algebra\\operator_algebra.texi

@settitle Package operator_algebra: A Tool for Operator Manipulation in Maxima.

@ifinfo
@macro var {expr}
<\expr\>
@end macro
@end ifinfo

@dircategory Mathematics/Maxima
@direntry
* Package operator_algebra: A Maxima package for operator algebras
@end direntry

@menu
* Introduction to the package operator_algebra::
* Installation::
* Basic usage::
* Functions and Variables for operator_algebra::
@end menu
@node Top, Introduction to the package operator_algebra, (dir), (dir)
@top


@detailmenu
 --- The Detailed Node Listing ---

* Introduction to the package operator_algebra::
* Installation::
* Basic usage::
* Functions and Variables for operator_algebra::
@end detailmenu

@chapter Package operator_algebra
@node Introduction to the package operator_algebra, Installation, Top, Top
@section Introduction to the package operator_algebra

The operator_algebra package provides support for working with operators, particularly
quantum mechanical operators. In the context of this package, an operator is a linear 
function, but mathematical the necessities, such as the specifying domains and codomains, is
not supported.

As one application of this package, with a bit of programming, this package can do tasks such as 
normally order quantum creation and annihilation operators.

Barton Willis (Professor of Mathematics Emeriti of the University of Nebraska at Kearney) wrote and maintains 
the operator algebra package. The package was first made public in spring 2021.

@node Installation, Basic usage, Introduction to the package operator_algebra, Top
@section Installation 

To install the operator_algebra package, copy the folder @file{operator_algebra} to a location that Maxima
can find. Alternatively, push new members to the lists @code{file_search_maxima} and @code{file_search_lisp}
that will allow Maxima to find the package; for example, if you copy the operator_algebra package to the 
path "C:/maxima/operator_algebra/*", put the commands
@example
 push("C:/maxima/operator_algebra/*.mac", file_search_maxima);
 push("C:/maxima/operator_algebra/*.lisp", file_search_lisp);
@end example
into your Maxima initialization file. Doing so will allow Maxima to load the package operator_algebra.

To use the package, you must manually load it, the package does not autoload. Loading the package is done 
with the command
@example
(%i1)  load("operator_algebra")$
@end example
To run the regression tests for the package, issue the command
@example
(%i2) batch("rtest_operator_algebra", 'test)$
@end example

@node Basic usage, Functions and Variables for operator_algebra, Installation, Top
@section Basic usage

Composition of operators is denoted by @code{"."}, Maxima's generic noncommutative 
multiplication operator; and the composition of an operator with itself is denoted by @code{"^^"},
Maxima's generic noncommutative exponentiation operator. As such, the settings of the option
variables @code{dot0nscsimp, dot1simp, dot0simp, dot1simp, dotassoc, dotconstrules, dotdistrib,
dotexptsimp, dotident}, and @code{dotscrules} can alter the way Maxima simplifies compositions of 
operators.

The package defines @code{operator} to be a feature. To tell Maxima that a symbol is an operator, 
it must be declared to be an operator; for example, to declare @code{f} and @code{g} to be operators
and @code{α} and @code{β} to be constant issue the commands

@example
(%i1)	declare([f,g],operator)$
(%i2)	declare([α,β], constant)$
@end example

Now we can compute some commutators:

@example
(%i3)	commutator(α*f, β*g);
(%o3)	α*β*(f . g)-α*β*(g . f)

(%i4)	commutator(f, f);
(%o4)	0

(%i5)	commutator(f,f^^2);
(%o5)	0

(%i6)	commutator(f + g, g);
(%o6)	-(g . (g+f))+g^^2+f . g

(%i7)	expand(%);
(%o7)	f . g - g . f
@end example
In the last example, we see that a user must sometimes manually use @code{expand} to fully 
simplify operators. As an alternative to manually expanding, a user can set the value
of the option variable @code{dotdistrib} to true:

@example
(%i8)	block([dotdistrib : true], commutator(f +g, g));
(%o8)	f . g - g . f
@end example

We can give an operator a formula by using @code{put}. For example, to define an operator @code{Dx}
that differentiates with respect to @code{x} and an operator @code{X} that multiplies an expression
by @code{X}, we first need to declare @code{Dx} and @code{X} to be operators; after that we can
define formulas for them using @code{put}:

@example
(%i1)	declare(Dx, operator, X, operator)$

(%i2)	put(Dx, lambda([q], diff(q,x)), 'formula);
(%o2)	lambda([q],'diff(q,x,1))

(%i3)	put(X, lambda([q],  x*q), 'formula);
(%o3)	lambda([q],x*q)
@end example
The function @code{operator_apply} applies a function to an argument:
@example
(%i4)	operator_apply(Dx, x^2);
(%o4)	Dx(x^2)
@end example
To use the formula for @code{Dx}, use the function @code{operator_express}:
@example
(%i5)	operator_express(%);
(%o5)	2*x
@end example
Finally, an example that uses both operators @code{Dx} and @code{X}:
@example
(%i6)	operator_apply(X.Dx.X, x^2);
(%o6)	X(Dx(X(x^2)))

(%i7)	operator_express(%);
(%o7)	3*x^3
@end example

In output %o6 above, we see that @code{operator_apply} effectively changes the dotted notation
for function composition (in this case @code{X.Dx.X}) to traditional parenthesized function
notation @code{X(Dx(X(x^2)))}. The traditional notation allows us to use the @code{simplifying}
package to define an operator as a simplifying function. (The source code for the @code{simplifying}
package has some user documentation and some examples, but there is no other documentation for
this package.)

To define our operators @code{Dx} and @code{X} to be simplifying operators, we start by loading the 
@code{simplifying} and defining predicates that detect if the main operator
of an expression is @code{Dx} or @code{X}. 
@example
(%i1)	load(simplifying)$
(%i2)	Dx_p(e) := not mapatom(e) and inpart(e,0) = 'Dx$
(%i3)	X_p(e) := not mapatom(e) and inpart(e,0) = 'X$
@end example
After that, we can define a simplification function for @code{Dx} that applies the rule 
@code{ Dx . X = Dx + X.Dx} that moves all the derivative operators to the right of all 
multiplication operators @code{X}; our code is
@example
(%i4)	simp_Dx (e) := block([],
	    /* Dx . X = Dx + X.Dx */
	    if X_p(e) then (
	        Dx(first(e)) + X(Dx(first(e))))
	   else simpfuncall(Dx,e))$
	    
(%i5)	simplifying('Dx, 'simp_Dx)$

@end example
Some simple examples
@example
(%i6)	operator_simp(Dx . X);
(%o6)	X . Dx+Dx

(%i7)	block([dotdistrib : true], operator_simp(Dx . X^^2 - X^^2 . Dx));
(%o7)	2*(X . Dx)+Dx
@end example

@node Functions and Variables for operator_algebra, , Basic usage, Top
@section Functions and Variables for operator_algebra

@heading Predicates
The @code{operator_algebra} package defines a predicate @code{operatorp} for detecting if a symbol is a 
declared operator; a predicate @code{operator_adjointp} for detecting if and expression is an
operator adjoint nounform; and five general purpose predicates @code{exptp, ncexptp, nctimesp, timesp},
and @code{plusp} that return @code{true} if and only if the main operator of a Maxima expression is 
@code{^, ^^, .,} and @code{+}, respectively.

@deffn {Function} exptp (@code{e})

The function call @code{exptp(e)} returns true if the operator of the expression @code{e} is 
@code{^}; otherwise it returns false. The main operator of an expression is determined by the Maxima 
function @code{inpart}, not @code{part}.
@end deffn

@emph{Examples}

@example
(%i1)	exptp(x);
(%o1)	false

(%i2)	exptp(x^2);
(%o2)	true
@end example


@deffn {Function} ncexptp (@code{e})

The function call @code{ncexptp(e)} returns true if the operator of the expression @code{e} is 
@code{^^}; otherwise it returns false. The main operator of an expression is determined by the Maxima 
function @code{inpart}, not @code{part}.
@end deffn

@emph{Examples}

@example
(%i1)	ncexptp(x^2);
(%o1)	false

(%i2)	ncexptp(x^^2);
(%o2)	true
@end example

@deffn {Function} nctimesp (@code{e})

The function call @code{nctimesp(e)} returns true if the operator of the expression @code{e} is 
@code{.}; otherwise it returns false. The main operator of an expression is determined by the Maxima 
function @code{inpart}, not @code{part}.
@end deffn

@emph{Examples}

@example
(%i1)	nctimesp(x * y);
(%o1)	false

(%i2)	nctimesp(x . y);
(%o2)	true
@end example

@deffn {Function} operator_adjointp (@code{e})

The function call @code{operator_adjointp(e)} returns true if the operator of the expression @code{e} is 
@code{operator_adjoint}; otherwise it returns false. The main operator of an expression is determined by the 
Maxima function @code{inpart}, not @code{part}.
@end deffn

@emph{Examples}

@example
(%i1) declare(f,operator)$

(%i2) operator_adjoint(f);
(%o2) operator_adjoint(f)

(%i3) operator_adjointp(%);
(%o3) true

(%i4) operator_adjointp(a+b);
(%o4) false
@end example


@deffn {Function} timesp (@code{e})

The function call @code{timesp(e)} returns true if the operator of the expression @code{e} is 
@code{*}; otherwise it returns false. The main operator of an expression is determined by the Maxima 
function @code{inpart}, not @code{part}.
@end deffn

@emph{Examples}

@example
(%i1)	timesp(x * y);
(%o1)	true

(%i2)	timesp(x . y);
(%o2)	false
@end example


@deffn {Function} plusp (@code{e})

The function call @code{plusp(e)} returns true if the operator of the expression @code{e} is 
@code{+}; otherwise it returns false. The main operator of an expression is determined by the Maxima 
function @code{inpart}, not @code{part}.
@end deffn

@emph{Examples}
@example
(%i1)	plusp(1);
(%o1)	false

(%i2)	plusp(1+x);
(%o2)	true
@end example

@heading Functions

@deffn {Function} get_operator_formula (@code{e})

When @code{e} is a declared to be an operator with a function  that is defined by @code{put}, the function 
call @code{ get_operator_formula (e)} returns the function; otherwise,  @code{get_operator_formula(e)}
returns false.

@end deffn 
@emph{Examples}
@example
(%i1) declare(f,operator)$

(%i2) put(f, lambda([q], 5*q), formula)$

(%i3) get_operator_formula(f);
(%o3) lambda([q], 5 q)

(%i4) get_operator_formula(g);
(%o4) false
@end example

@deffn {Function} operator_apply(@code{e},@code{ψ})

The function call @code{operator_apply(@code{e},@code{ψ})} applies an operator or a dotted form operator to
an argument @code{ψ}. If the first argument is not an operator or a a dotted form operator, the result
is an error.
@end deffn

@emph{Example}

@example

(%i1) declare([f,g], operator)$

(%i2) operator_apply(f, ψ);
(%o2) f(ψ)

(%i3) operator_apply(f.g, ψ);
(%o3) f(g(ψ))

(%i4) operator_apply(h, ψ);
I don't know how to apply  h  to  ψ
@end example

@deffn {Function} operator_express (@code{e})

For each operator in the input @code{e}, the function call @code{operator_express (e)} looks up 
the formula (if any) for the operator and applies it to the input.

@end deffn

@emph{Example}

@example
(%i1) declare(f,operator)$

(%i2) put(f, lambda([q], 42*q), 'formula)$

(%i3) operator_apply(f,ψ);
(%o3)                                f(ψ)
(%i4) operator_express(%);
(%o4)                                42 ψ
(%i5) operator_apply(f^^3,ψ);
(%o5)                             f(f(f(ψ)))
(%i6) operator_express(%);
(%o6)                               74088 ψ
(%i7)
@end example

@deffn {Function} operator_adjoint (@code{e})

The function call @code{operator_adjoint (e)} returns the operator adjoint of @code{e}. In Quantum 
Mechanics, the adjoint is generally known as the @emph{hermitian conjugate}.

@end deffn

The operator adjoint is a @emph{simplifying function}. The operator adjoint of and operator returns 
an @code{operator_adjoint} nounform; for example
@example
(%i1)	declare(F,operator,G, operator)$

(%i2)	operator_adjoint(F);
(%o2)	operator_adjoint(F)
@end example

The operator adjoint is an involution, that is the operator adjoint is its own inverse:
@example
(%i3)	operator_adjoint(%);
(%o3)	F
@end example


To tell Maxima, that the adjoint of @code{F} is @code{G}, use a @code{put} statement:
@example
(%i4)	(put(F,G, operator_adjoint),put(G,F, operator_adjoint))$
@end example

The adjoint is additive
@example
(%i5)	operator_adjoint(2*F - 5*G);
(%o5)	2*G-5*F

(%i6)	operator_adjoint(P .Q);
(%o6)	Q . P

(%i7)	operator_adjoint(F^^2);
(%o7)	G^^2
@end example

The adjoint of a complex number is the complex conjugate of the number; for a matrix, 
it is the transpose of the element-wise adjoint of the matrix:

@example
(%i8)	operator_adjoint(2+%i);
(%o8)	2-%i
(%i11)	operator_adjoint(matrix([1,%i, 3],[4,5,6]));
(%o11)	matrix([1, 4], [-%i, 5], [3, 6])

(%i12)	operator_adjoint(matrix([0,F],[G,0]));
(%o12)	matrix([0, F], [G, 0])
@end example

@deffn operator_simp (@code{e})

For an operator @code{e} in dot form, the function call @code{operator_simp(e)} returns a simplified version
the operator @code{e}. Unless a user has defined simplification rules for the constitute parts of the
operator @code{e}, no simplification will occur.
@end deffn 

@emph{Examples}

In this example we'll define Quantum position and momentum operators @code{Q} and @code{P}, respectively.
And we'll define a simplification rule that orders the position operators to be before the momentum operators.
We start by declaring @code{P} and @code{Q} to be operators. The Planck constant divided by @code{2 π}, denoted
as @code{ħ} needs to be declared to be a constant.
@example
(%i1) declare([P,Q],operator)$

(%i2) declare(ħ,constant)$

@end example
Now we define @code{P} to be a simplifying function and we implement the rule @code{P Q --> Q P  - %i*ħ}
@example
(%i3) /* Implement the rule P Q --> Q P  - %i*ħ */
simp_P(e) :=
  if Q_p(e) then Q(P(first(e))) - %i*ħ*first(e)
  else simpfuncall('P,e)$

(%i4) simplifying('P, 'simp_P)$
@end example
We end with a simple test:
@example
(%i5) operator_simp(Q^^4 . P^^2 - P^^2 . Q^^4);
(%o5) 8*%i*ħ*Q^^3 . P+12*ħ^2*Q^^2
@end example

@deffn {Function} dot_form (@code{e})

The function call @code{dot_form(e)} converts an expression @code{e} from a parenthesized functional form to 
a ``dot form.''
@end deffn

@emph{Examples}
Assuming @code{F} and @code{G} are declared operators, we have 

@example
(%i1)	dot_form(F(G(x)));
(%o1)	F . G . x

(%i2)	dot_form(F(F(x)) - F(G(x)));
(%o2)	F^^2 . x-F . G . x
@end example

@deffn {Function} operatorp (e)

The function call @code{operatorp (e)} returns true if the input 
@code{e} is a declared operator; otherwise it returns false.

@end deffn

@emph{Examples}
@example
@group
(%i1)	operatorp(q);
(%o1)	true

(%i2)	declare(q,operator);
(%o2)	done

(%i3)	operatorp(q);
(%o3)	true
@end group

The predicate @code{operatorp} does @emph{not} recognize linear combinations or compositions of operators to 
be an operator; for example

@group
(%i4)	operatorp(5*q);
(%o4)	false
@end group
@end example

@deffn {Function} commutator (@code{f,g})

The function call @code{commutator(f,g)} returns @code{operator_simp(f.g - g.f)}. 
@end deffn

@node Function and Variable Index, , Top, Top
@appendix Function and Variable index
@printindex fn
@printindex vr

@bye

